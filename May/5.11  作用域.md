# 5.11  作用域

标签（空格分隔）： JavaScript从入门到放弃

---

## 1.作用域  
作用域指的是变量和函数的可访问范围。他们是以函数来划分的，每个函数就是一个作用域。  
作用域分为：全局作用域和局部作用域。  
###1.1 全局作用域  
在函数外声明的变量或者函数就是全局作用域，他们在任何地方都可以访问的倒，包括后面的script标签。  

这里的全局，指的是整个文档。  

**注意：如果一个变量没有使用var关键字声明，那么不管它是在函数内部还是函数外部，都是一个全局变量**  

>所有的全局变量，都是`window`下的属性。 `window` 是一个全局属性，它在任何地方都可以访问的到，他的属性也是一样。  
  
  *注意：声明变量的时候一定要加var，同时，避免使用全局变量*  
  

    <script>
        function aaa(){
            a=10;           //这个a没有使用var关键字声明，是全局变量。  
            
        }
        fn();
        console.log(a);
        console.dir(window);    //此时可以在window属性中找到a
    </script>

###1.1.2 局部作用域  
在函数内部声明的变量或者函数是局部作用域，他们只能在函数声明中使用，在外面是访问不到的。  
因为函数可以嵌套函数，在函数内部声明的变量与函数，它的子函数是可以访问的到的。  

    function fn(){
        var a=10;
        function fn1(){
            console.log("这里是fn1")；
            console.log(a);  
            
            //在函数fn内部定义的a，作用域范围是整个函数fn内部，即使是fn内部嵌套的函数也可以访问的到变量a
            
        }
        fn1();
    }
    fn();   //输出结果有两个："这里是fn1"，10； 
    
    console.log(a);  
    
    //这个会报错。因为a是在函数fn内部声明的，它的作用域范围只有函数fn内部，在函数fn外部是调用不到a的。
    
此时，上面的函数有两个局部作用域，分别是函数fn的局部作用域和函数fn1的局部作用域。  


###1.3 作用域链  
作用域链指的是作用域中函数和变量的查找规则。  
作用域中函数和变量的查找规则类似CSS，都是从里往外找。  

一个作用域中，函数要找到一个变量，他会从自身开始，一层一层的往外去寻找，知道找到位置。如果最外层也没有找到，那么就会报错。  

    var n=1;
    function fn(){
        var n=10;
        function fn1(){
            var n=20;
            console.log(n);     //n=20
        }
        fn1();
        console.log(n);         //n=10
    }
    fn();
    console.log(n);             //n=1
    
根据作用域链的查找原则，如果函数在自己内部找到了这个变量，那么就不会向上继续查找。 在上面的例子中，最里层的fn2执行时，寻找变量n，在函数fn2内内部找到了变量n=20；fn2函数的输出结果就是n=20. 函数fn1执行时，同样会在函数自身内部查找变量n，找到n=10；输出结果就是n=10。依次类推，最外层的输出结果就是n=1.

### 1.4 预解析(变量/函数提升)  
>变量和函数都会有一个解析的过程。在作用域中，会提前把函数和变量解析，解析的结果放在作用域的最开始的位置。    

作用域的解析过程:

 1. 找到`var`, `function`两个关键字与参数（形参）。 
 2. 如果查找到一个变量(var关键字和参数)，会将他们读取并赋予一个undedined的值，如果找到函数，则会把函数整个读取。  
 3. 把找到的这些变量和函数，放到作用域最开始的位置。
 4. 逐行解析代码。
 
*关于函数的预解析，只有函数声明会被预解析，所以可以在函数声明前去调用，而函数表达式不会被预解析，则不能再函数声明前调用函数。* 

#### 1.4.1预解析的例子1：

    var b=10;
	function fn(){
		//var b=undefined;
		console.log('函数内b',b);	// undefined
		    var b=20;
		}
	fn();
	console.log('函数外b',b)	

在上面的例子中，首先，预解析函数，发现关键字 `var` 和 `function` ，将这两个内容读取，此时，变量 `b` 被赋予 `undefined` 的值，而函数声明 `fn` 被读取，然后将他们放在作用域的顶部，开始按照JS的顺序执行代码。

当执行到 `var b=10;` 时，发现变量 `b` 有赋值，此时变量 `b` 的值就等于10.继续执行函数，发现函数 `fn` 被调用，然后开始执行函数声明 `fn` ，进入函数声明 `fn` 的作用域，再次执行预解析，发现关键字 `var` ，将这个作用域中的变量 `b` 放在作用域最上方并赋予 `undedined`。然后按照顺序执行代码，执行中发现需要输出函数b，按照作用域链的原理在函数内部寻找变量 `b` 在作用域顶部找到，此时作用域b的值是`undefined`，所以这里输出`undefined`  

继续往下执行代码，发现`var b = 20`; 这时，这个函数声明里的变量`b`的改为20。  函数执行完毕，继续往下执行代码，发现需要输出变量`b`，按照作用域链的规则在这个作用域中寻找变量`b`，此时这个作用域中的 `b` 的值是10，那么就在控制台输出10.  

####1.4.2 预解析的例子2

    var c=10;
	function fn1(){
		console.log('函数内c',c);	//10
		c=20;
	}
	fn1();
	console.log('函数外c',c)	//20
	
这个就是正常的代码运行顺序，需要注意的是此时`c=20`是给C赋值而不是一个全局变量。  

####1.4.3 预解析的例子3
	

    var d=12;
	function fn2(d){
		//var d=undefined;
		console.log('函数内d',d);	//undefined 12
		d=24;
	}
	fn2();
	console.log('函数外d',d)		//12

###1.5 闭包  
>函数要嵌套函数，函数声明嵌套函数声明，子函数访问父级函数的变量，这个时候就产生了一个闭包环境  

根据作用域的原理，子函数里的变量，只能在它本身大括号里访问，在函数外面是访问不到的

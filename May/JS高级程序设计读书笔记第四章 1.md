# JS高级程序设计读书笔记:第四章

标签（空格分隔）： JavaScript从入门到放弃 JS高级程序设读书笔记

---

#1.基本类型和引用类型  
> ECMAScript中的数据类型分为两大类：基本类型和引用类型。  
其中，基本类型是指简单的数据段：String，Number，Boolean，undefined，Null
引用类型是指可能由多个值构成的对象： Object，Array等  

##1.1 复制变量的值  

###1.1.0  堆和栈  
在了解JS中的复制变量值之前，我们需要先了解两个概念:**堆**和**栈**  

堆和栈是数据结构中的一个概念，  
>栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。      

栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。
  
>堆（操作系统）： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收，分配方式倒是类似于链表。  

堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定。所以调用这些对象的速度要相对来得低一些。  

参考链接：[百度百科:堆栈](http://baike.baidu.com/link?url=eoPXt8z2o1-G2Xuve8Lbu8Tf5jVuIS2k68z9rSZ5Ar_ufHvQLmNic2QV7CcEshq5Z0ZmEwcn7sNWBZIiLD4-Pa)  

###1.1.1 复制基础类型

如果一个变量想另一个变量复制基本类型的值的时候，会在变量对象上创建一个新的值，然后把这个值复制到新分配的变量上。

    var a=10;
    var b=a;
    var a=20;
    console.log(a,b)        //这个时候a是20 b是10
    
在上面这个例子中，var b=a； 把a赋给了b，这个时候a和b是独立的，赋值只是把a的值10复制了一份赋给了b，他们a和b可以参与任意操作并互不影响。所以当a的值在下方做更改的时候，b的值并没有更改。  

###1.1.2 复制引用类型  
当一个变量向另外一个变量复制引用类型的值的时候，同样也会将储存在变量对象中的值复制一份放到为新变量分配的控件中。  
但是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。  复制操作结束后，两个变量会指向同一个对象，所以，如果改变其中一个变量，另外一个变量也会做相应的改变。  

    var obj1 = new Object();
    var obj2 = obj1;
    obj1.name = "google";
    console.log(obj2.name);     //google
    
在这里 我们可以把指针看成一个钥匙，而引用类型的值看成一个箱子。
以上面代码为例，我们在复制一个对象的时候，并不是像复制基础类型一样，把值复制了过去，实际上我们复制的，是打开对象这个箱子的钥匙，复制完成之后，这个对象有两把钥匙，一把在 `obj1` 手中，一把在 `obj2` 手中。这个时候我们用 `obj1` 的钥匙打开了箱子 放入一个宝物： `"name" = "google";` 那么我们用 `obj2` 的钥匙打开这个箱子，同样可以看到这个宝物。  

##1.2 传递参数
明白了变量的复制，那么我们要开始学习传递参数。  
>在ECMAScript中，所有函数的参数都是按值去传递的    

也就是说，把函数部的值复制给函数内部的参数。就和吧一个变量复制到另一个变量是一样的。  
在函数传参过程中，传递的参数会被复制给一个局部变量。如果在向函数传递的参数是一个引用类型，那么会把换这个值在堆中的地址复制给一个局部变量，也就是说这个局部变量对引用类型的修改会反映在函数的外部。  

    var a=10;
    function sum(num){
        num+=10;
        return num;
    }
    console.log(a);          //10
    console.log(sum(a));     //20  
    
在这个例子中，传递的是基础类型的参数，参数num和变量a是互不认识的，他们只是有一个相同的值10。函数内的局部变量num的修改不影响变量a的值。 

    var obj1 = new Object();
    function aa(obj){
        obj.name = "aa";
    }
    aa(obj1);
    console.log(obj1);      //Object { name: "aa" }

这个时候，obj1的值也发生了变化。 
在函数执行的时候，创建一个局部变量obj，然后传入参数obj1，这个时候，参数obj和参数obj1指向的对象是一个对象，所以在函数内部对obj进行修改的时候，函数外的obj1的值也发生了变化。

    var obj2 = new Object();
    function bb(obj){
        obj.name = "bb";
        obj = new Object();
        obj.name = "cc";
    }
    bb(obj2);
    console.log(obj2);      //Object { name: "bb" }
    
在这个例子中，当函数执行时，传入参数obj2，这个时候参数obj和obj2指向的是同一个对象，obj修改属性的时候obj2也有对应的反映。但是在修改完属性后，参数obj修改了自己的指向，创建了一个新的局部对象，这个时候，obj和obj2的指向对象已经不同了，所以在后面obj修改属性的时候obj2不会有对应反映。  

##1.3 检测类型  
检测基本类型的时候`typeof`是一个很得力的助手，但是在检测引用类型的时候就不是那么方便了。  这个时候，我们需要使用`instanceof`
语法：
    对象名 instanceof 对象类型  

`instanceof` 的返回结果是一个Boolean值，这样可以确定你的数据是否是这个数据类型。   

# 2.执行环境及作用域
执行环境定义了变量和函数有权访问的其他数据，决定了他们各自的行为。每个执行环境都有与之关联的变量对象。（*实际上我认为可以把直径环境的概念理解为作用域*）  
>全局执行环境是 `window` 对象。  

没个函数都有自己的执行环境。  
##2.1 作用域链  


    








